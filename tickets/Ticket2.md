## Файловые системы

### Inode

Узел `Inode` представляет объект файловой системы с уникальным идентификатором.
`inode_operations` определяет операции, которые работают напрямую с inode,
а `file_operations` относится к методам, которые работают с файлами и директориями.

```cpp
struct inode {
    unsigned                  long i_ino;
    umode_t                   i_mode;
    uid_t                     i_uid;
    struct timespec           i_atime;
    struct timespec           i_mtime;
    struct timespec           i_ctime;
    unsigned short            i_bytes;
    struct inode_operations   *i_op;
    struct file_operations    *i_fop;
    struct super_block        *i_sb;
    ...  <-- //TODO: дополнить
};
```
### mount/umount

`mount` -- "монтируем" файловую систему. Например, `mount /dev/cdrom /mnt/cdrom` монтирует устройство /dev/cdrom в каталог /mnt/cdrom

`umount` -- размонтируем устройство, пример: `umount -f /cdrom`

В UNIX существует только один корневой каталог, а все остальные файлы и каталоги вложены в него.
Чтобы получить доступ к файлам и каталогам на каком-нибудь диске,
необходимо смонтировать этот диск командой `mount`.
Например, чтобы открыть файлы на CD, нужно,
говоря простым языком, сказать операционной системе:
«возьми файловую систему на этом компакт-диске и покажи её
в каталоге /mnt/cdrom». Все файлы и каталоги, находящиеся
на CD, появятся в этом каталоге /mnt/cdrom, который
называется точкой монтирования (англ. mount point).

`mount namespaces` -- //TODO:

### Файловые дескрипторы

**Дескриптор файла** - это целое число без знака,
с помощью которого процесс обращается к открытому файлу.

**Таблица дескрипторов файлов**:

Преобразует индексы таблицы (дескрипторы файлов) в
указатели на открытые файлы. Для каждого процесса в
области u_block создается своя собственная таблица
дескрипторов. Каждая запись такой таблицы содержит
следующие поля: поле флагов и указатель на файл.
Допустимо не более OPEN_MAX дескрипторов файлов.
Таблица дескрипторов файлов имеет следующую структуру.

**open()**:
![text](https://pp.userapi.com/c840335/v840335240/5e643/fs0jPhWKnVg.jpg)

**close()**:
![text](https://pp.userapi.com/c840335/v840335240/5e64f/yNP733EaEvE.jpg)

**chroot**:
```cpp
int chroot(const char *path);
```

![text](https://pp.userapi.com/c840335/v840335240/5e657/cIWdpz0WxaM.jpg)

**dup, dup2**:
```cpp
int dup(int oldfd);
int dup2(int oldfd, int newfd);
```

![man](https://pp.userapi.com/c840121/v840121240/841b4/z_r2c9rPLwI.jpg)

### Umask
В структуре inode, рассмотренной ранее, хранится uid
пользователя - владельца этого файла. И 12 бит, которые
называются mode и собственно являются правами доступа.
Они разделены на 4 октета. Первые три бита рассмотрим
позже, оставшиеся 9 отвечают (от старших к младшим) за
права доступа владельца файла, его группы и всех остальных.
Первый (старший) бит октета означает наличие или
отсутствие права на чтение (r - read) , второй -
на запись (w - write) , третий - на исполнение
(x - execute). Пример: rwxr-xr-x. У владельца файла
есть полный доступ, у его группы и
всех остальных - только на чтение и исполнение.

С директориями чуть сложнее. Как мы знаем, директория - это таблица (или map) из названия в соответствующий inode. Право r дает возможность смотреть левую колонку таблицы (с именами), право x дает просмотр правой (с inode), право w дает возможность изменять содержимое обоих колонок. То есть, если на папку права r--, можно посмотреть список файлов в ней, но к ним нельзя никак перейти (забавный факт №42).

Тут у нас возникает проблема. Представим директорию /tmp,
в которой хранятся временные файлы всех пользователей. Допустим,
пользователи petya и vasya хранят там свои картиночки. Если им
обоим дать право w, они смогут удалить файлы друг друга, что
не есть хорошо. Если им не давать этого права, они не смогут
не то что удалить за собой файлы, они не смогут их даже создать
. Тут на помощь приходит первый октет в mode. Его последний
бит называется sticky bit. Раньше от отвечал за что-то вроде
"запрет выгружения исполняемого файла из памяти в swap", но
теперь это используется по другому: Если у директории установлен
sticky bit, удалять файлы из неё может только владелец файла.
Собственно, так решается проблема - устанавливаем у tmp
sticky bit, даём Пете с Васей права w, они могут создавать
там любые временные файлы, но удалять они смогут только то,
что создали. Такие типичные права
доступа на общую папку выглядят как 1777.

Два последние бита mode, которые мы до сих пор не рассмотрели.
Они называются setuid и setgid. Если они установлены в 1,
то процесс запускается с правами, не текущего пользователя,
а владельца (группы владельца, если gid) файла.

**umask(2)**
устанавливает маску создания режима доступа к файлу.

```cpp
mode_t umask(mode_t mask);
```
**umask()** устанавливает в вызывающем процессе значение
 маски (umask) создания режима доступа к файлу равным
mask & 0777 (т.е. из mask используются только биты прав
доступа к файлу) и возвращает предыдущее значение маски.

**chmod, chown**:

[chmod](http://ru.manpages.org/chmod/2)
[chown](http://ru.manpages.org/chown/2)

### Ссылки

Знакомые всем ссылки-ярлыки
* Hard links
* Soft (symbolic) links

**SOFT** В структуре inode указано, что эта нода -
символьная ссылка, так же там содержится path.
Все обращения к этой inode переадресуются на path

**HARD** Два имени в разных папках содержат на одну и
ту же inode. Работает только в пределах одной FS.
Чтобы узнать, когда на самом деле удалять файл,
inode хранит количество hard ссылок на неё.
Так как все записи у нас одинаковые, мы не можем
узнать, кто оригинал.

`man ln` расскажет всё о том, как делать ссылки.

